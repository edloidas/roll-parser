---
description: RNG usage standards
globs: src/rng/**,src/evaluator/**
alwaysApply: false
---

# RNG Standards

## Interface

All dice rolling MUST use the RNG interface:

```typescript
interface RNG {
  next(): number;                              // [0, 1)
  nextInt(min: number, max: number): number;   // [min, max] inclusive
}
```

## Rules

1. **Never use Math.random() directly** in roll logic
2. **Inject RNG** via options parameter
3. **Default to SeededRNG** when no RNG provided
4. **MockRNG for tests** - returns predefined sequence

## MockRNG Behavior

```typescript
const mock = createMockRng([3, 5, 1]);
mock.nextInt(1, 6);  // Returns 3
mock.nextInt(1, 6);  // Returns 5
mock.nextInt(1, 6);  // Returns 1
mock.nextInt(1, 6);  // Throws! (exhausted)
```

- MockRNG MUST throw on exhaustion (never wrap)
- This catches incorrect roll counts in tests

## Usage in Tests

```typescript
import { describe, it, expect } from 'bun:test';
import { createMockRng } from '@/rng/mock';

describe('roll', () => {
  it('should roll exact values with MockRNG', () => {
    const rng = createMockRng([4, 2, 6]);

    const result = roll('3d6', { rng });

    expect(result.total).toBe(12);  // 4 + 2 + 6
    expect(result.rolls).toEqual([
      { result: 4, sides: 6 },
      { result: 2, sides: 6 },
      { result: 6, sides: 6 },
    ]);
  });
});
```

## SeededRNG for Reproducibility

```typescript
// Same seed = same sequence
const rng1 = new SeededRNG('test-seed');
const rng2 = new SeededRNG('test-seed');

expect(rng1.nextInt(1, 6)).toBe(rng2.nextInt(1, 6));
```
